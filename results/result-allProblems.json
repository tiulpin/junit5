{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for field 'reason'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ConditionEvaluationResult.java",
      "language": "JAVA",
      "line": 66,
      "offset": 16,
      "length": 16,
      "code": {
        "startLine": 64,
        "length": 16,
        "offset": 48,
        "surroundingCode": "\tprivate final boolean enabled;\n\n\tprivate final Optional<String> reason;\n\n\tprivate ConditionEvaluationResult(boolean enabled, String reason) {"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "0651536d8bd197ad423cc16bd049881b74206170c319933f1cc740158a0250a9"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'reason'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestWatcher.java",
      "language": "JAVA",
      "line": 61,
      "offset": 54,
      "length": 16,
      "code": {
        "startLine": 59,
        "length": 16,
        "offset": 89,
        "surroundingCode": "\t * potentially <em>empty</em>\n\t */\n\tdefault void testDisabled(ExtensionContext context, Optional<String> reason) {\n\t\t/* no-op */\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "6f28a5d48ae1561fd0875ec85f15fcbb75d97b1ed0c711443498e64b9148715a"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'testDescriptor'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java",
      "language": "JAVA",
      "line": 129,
      "offset": 34,
      "length": 44,
      "code": {
        "startLine": 127,
        "length": 44,
        "offset": 37,
        "surroundingCode": "\t}\n\n\tprivate Resolution toResolution(Optional<? extends ClassBasedTestDescriptor> testDescriptor) {\n\t\treturn testDescriptor.map(it -> {\n\t\t\tClass<?> testClass = it.getTestClass();"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "fcf9dc427a244553ffdb22539bf1454784f6d4c3597e645ee8e1e332e1a32c57"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for parameter 'target''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java",
      "language": "JAVA",
      "line": 164,
      "offset": 60,
      "length": 16,
      "code": {
        "startLine": 162,
        "length": 16,
        "offset": 124,
        "surroundingCode": "\t * invocation; never {@code null} though potentially empty\n\t */\n\tprivate Object[] resolveParameters(Executable executable, Optional<Object> target, Optional<Object> outerInstance,\n\t\t\tExtensionContext extensionContext, ExtensionRegistry extensionRegistry) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "cd9ec1aa595b77d6c4f1ad98f1d308cbaf0b023fd66102d071f5fee205d1d5f8"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for parameter 'outerInstance''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java",
      "language": "JAVA",
      "line": 164,
      "offset": 85,
      "length": 16,
      "code": {
        "startLine": 162,
        "length": 16,
        "offset": 149,
        "surroundingCode": "\t * invocation; never {@code null} though potentially empty\n\t */\n\tprivate Object[] resolveParameters(Executable executable, Optional<Object> target, Optional<Object> outerInstance,\n\t\t\tExtensionContext extensionContext, ExtensionRegistry extensionRegistry) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "f47fec1d4544cc169d7dbcea82a93b4ba8a87ba35cce4e21c0133127d22d7627"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for parameter 'target''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java",
      "language": "JAVA",
      "line": 141,
      "offset": 52,
      "length": 16,
      "code": {
        "startLine": 139,
        "length": 16,
        "offset": 116,
        "surroundingCode": "\t * invocation; never {@code null} though potentially empty\n\t */\n\tprivate Object[] resolveParameters(Method method, Optional<Object> target, ExtensionContext extensionContext,\n\t\t\tExtensionRegistry extensionRegistry) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "9ebf732252261afebbaca63c6bc6581588886b64e8e8c171454f939d76d564de"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for parameter 'outerInstance''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java",
      "language": "JAVA",
      "line": 71,
      "offset": 50,
      "length": 16,
      "code": {
        "startLine": 69,
        "length": 16,
        "offset": 72,
        "surroundingCode": "\t * interceptors}\n\t */\n\tpublic <T> T invoke(Constructor<T> constructor, Optional<Object> outerInstance, ExtensionContext extensionContext,\n\t\t\tExtensionRegistry extensionRegistry, ReflectiveInterceptorCall<Constructor<T>, T> interceptorCall) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "26ff9825f9bc7ad880a78210dcf530a66e07a73cf71652dd16afa0a806679b26"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for field 'target''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/DefaultParameterContext.java",
      "language": "JAVA",
      "line": 35,
      "offset": 16,
      "length": 16,
      "code": {
        "startLine": 33,
        "length": 16,
        "offset": 77,
        "surroundingCode": "\tprivate final Parameter parameter;\n\tprivate final int index;\n\tprivate final Optional<Object> target;\n\n\tDefaultParameterContext(Parameter parameter, int index, Optional<Object> target) {"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "5a633c1e6409728b8fcef8bcc7d794a8a2f1eab6ee1fd44f2d6fd340356ca0fc"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for parameter 'target''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/DefaultParameterContext.java",
      "language": "JAVA",
      "line": 37,
      "offset": 58,
      "length": 16,
      "code": {
        "startLine": 35,
        "length": 16,
        "offset": 98,
        "surroundingCode": "\tprivate final Optional<Object> target;\n\n\tDefaultParameterContext(Parameter parameter, int index, Optional<Object> target) {\n\t\tPreconditions.condition(index >= 0, \"index must be greater than or equal to zero\");\n\t\tthis.parameter = Preconditions.notNull(parameter, \"parameter must not be null\");"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "aa60a9a7b44ba3e73e921eff033cc9a1e19333177602f38928de0ad6712ade7b"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for parameter 'target''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/MethodInvocation.java",
      "language": "JAVA",
      "line": 30,
      "offset": 34,
      "length": 16,
      "code": {
        "startLine": 28,
        "length": 16,
        "offset": 71,
        "surroundingCode": "\tprotected final Object[] arguments;\n\n\tMethodInvocation(Method method, Optional<Object> target, Object[] arguments) {\n\t\tthis.method = method;\n\t\tthis.target = target;"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "d62de96f87175307d98ce3433fb2d01b15f8043a309b64051b36b1c62e012046"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for field 'target''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/MethodInvocation.java",
      "language": "JAVA",
      "line": 27,
      "offset": 18,
      "length": 16,
      "code": {
        "startLine": 25,
        "length": 16,
        "offset": 50,
        "surroundingCode": "\n\tprotected final Method method;\n\tprotected final Optional<Object> target;\n\tprotected final Object[] arguments;\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "8dcf469275de1585933636d2e0938fa8d81f686f879872565ef2012804b0c5c9"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'optional'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TestInfoParameterResolver.java",
      "language": "JAVA",
      "line": 87,
      "offset": 37,
      "length": 11,
      "code": {
        "startLine": 85,
        "length": 11,
        "offset": 41,
        "surroundingCode": "\t\t}\n\n\t\tprivate static Object nullSafeGet(Optional<?> optional) {\n\t\t\treturn optional != null ? optional.orElse(null) : null;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "82c87f4d6d88d452edcaff4aeb3875675941ebb40ca0f361113f11fc8f35b0bb"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional>' used as type for field 'testClass'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TestInfoParameterResolver.java",
      "language": "JAVA",
      "line": 45,
      "offset": 17,
      "length": 18,
      "code": {
        "startLine": 43,
        "length": 18,
        "offset": 86,
        "surroundingCode": "\t\tprivate final String displayName;\n\t\tprivate final Set<String> tags;\n\t\tprivate final Optional<Class<?>> testClass;\n\t\tprivate final Optional<Method> testMethod;\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "78f0621674ff18ea1624cb0ae69a68616065a132ecde6bc8a0a00f469be9d916"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for field 'testMethod'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TestInfoParameterResolver.java",
      "language": "JAVA",
      "line": 46,
      "offset": 17,
      "length": 16,
      "code": {
        "startLine": 44,
        "length": 16,
        "offset": 96,
        "surroundingCode": "\t\tprivate final Set<String> tags;\n\t\tprivate final Optional<Class<?>> testClass;\n\t\tprivate final Optional<Method> testMethod;\n\n\t\tDefaultTestInfo(ExtensionContext extensionContext) {"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "ce450629c0429cacb2fa57a4f1c3cf39510079e066c351673b1932feafc96246"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for parameter 'outerInstance''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DefaultTestInstanceFactoryContext.java",
      "language": "JAVA",
      "line": 28,
      "offset": 56,
      "length": 16,
      "code": {
        "startLine": 26,
        "length": 16,
        "offset": 103,
        "surroundingCode": "\tprivate final Optional<Object> outerInstance;\n\n\tDefaultTestInstanceFactoryContext(Class<?> testClass, Optional<Object> outerInstance) {\n\t\tthis.testClass = testClass;\n\t\tthis.outerInstance = outerInstance;"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "a371997ff534631358a488ec8232c7425aea371fed9a80b334f22b1d7e863be6"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for field 'outerInstance''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DefaultTestInstanceFactoryContext.java",
      "language": "JAVA",
      "line": 26,
      "offset": 16,
      "length": 16,
      "code": {
        "startLine": 24,
        "length": 16,
        "offset": 51,
        "surroundingCode": "\n\tprivate final Class<?> testClass;\n\tprivate final Optional<Object> outerInstance;\n\n\tDefaultTestInstanceFactoryContext(Class<?> testClass, Optional<Object> outerInstance) {"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "432ecd0ace3f3aafadb4a49c73c9435427552265579711a6e3d32a24a4654485"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for parameter 'outerInstance''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java",
      "language": "JAVA",
      "line": 285,
      "offset": 43,
      "length": 16,
      "code": {
        "startLine": 283,
        "length": 16,
        "offset": 46,
        "surroundingCode": "\t}\n\n\tprivate Object invokeTestInstanceFactory(Optional<Object> outerInstance, ExtensionContext extensionContext) {\n\t\tObject instance;\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "5ee63a4546c9fda6d75ec5dced680d399d6d680025ffa02fbed2b4b7e0a81828"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional used as type for parameter 'outerInstance''",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java",
      "language": "JAVA",
      "line": 329,
      "offset": 44,
      "length": 16,
      "code": {
        "startLine": 327,
        "length": 16,
        "offset": 47,
        "surroundingCode": "\t}\n\n\tprivate Object invokeTestClassConstructor(Optional<Object> outerInstance, ExtensionRegistry registry,\n\t\t\tExtensionContext extensionContext) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "7dfd3df268c57d83c5073107d38cf79d3224cd9dd60e2236bc99bcdf4ebdaf6d"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'outerInstances'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java",
      "language": "JAVA",
      "line": 274,
      "offset": 47,
      "length": 23,
      "code": {
        "startLine": 272,
        "length": 23,
        "offset": 144,
        "surroundingCode": "\t\t\tExtensionRegistry registry, ExtensionRegistrar registrar, ExtensionContext extensionContext);\n\n\tprotected TestInstances instantiateTestClass(Optional<TestInstances> outerInstances, ExtensionRegistry registry,\n\t\t\tExtensionContext extensionContext) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "aa983f25fb76b4b5bcdb752296fb2922014d89482b2f9fa413985bb43b92e198"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'identifiedTestDescriptor'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/UniqueIdFilter.java",
      "language": "JAVA",
      "line": 63,
      "offset": 48,
      "length": 34,
      "code": {
        "startLine": 61,
        "length": 34,
        "offset": 51,
        "surroundingCode": "\t}\n\n\tprivate Set<Description> determineDescendants(Optional<? extends TestDescriptor> identifiedTestDescriptor) {\n\t\t// @formatter:off\n\t\treturn identifiedTestDescriptor.map("
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-vintage-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "8b267f707dee0f24e0f8f582c47620f45db65fd4ae6554bd833457138a23f93e"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'identifiedTestDescriptor'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/UniqueIdFilter.java",
      "language": "JAVA",
      "line": 53,
      "offset": 4,
      "length": 34,
      "code": {
        "startLine": 51,
        "length": 34,
        "offset": 89,
        "surroundingCode": "\n\tprivate Deque<Description> determinePath(RunnerTestDescriptor runnerTestDescriptor,\n\t\t\tOptional<? extends TestDescriptor> identifiedTestDescriptor) {\n\t\tDeque<Description> path = new ArrayDeque<>();\n\t\tOptional<? extends TestDescriptor> current = identifiedTestDescriptor;"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-vintage-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "5f787ba5600f91628aa713318cd8ae2513500be80f0054e8042046c76b8b1bf9"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'parent'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/RunListenerAdapter.java",
      "language": "JAVA",
      "line": 195,
      "offset": 63,
      "length": 24,
      "code": {
        "startLine": 193,
        "length": 24,
        "offset": 66,
        "surroundingCode": "\t}\n\n\tprivate void fireExecutionStartedIncludingUnstartedAncestors(Optional<TestDescriptor> parent) {\n\t\tif (parent.isPresent() && canStart(parent.get())) {\n\t\t\tfireExecutionStartedIncludingUnstartedAncestors(parent.get().getParent());"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-vintage-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "615ed947b0e20de4da5c85d1c5e256859f352b0f387185045c3c54a233014004"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for field 'reason'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/FilterResult.java",
      "language": "JAVA",
      "line": 74,
      "offset": 16,
      "length": 16,
      "code": {
        "startLine": 72,
        "length": 16,
        "offset": 49,
        "surroundingCode": "\tprivate final boolean included;\n\n\tprivate final Optional<String> reason;\n\n\tprivate FilterResult(boolean included, String reason) {"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "592fca419f2865e13a89d41d5d1eb533cfc95460f2e22dd11f535cdf77fd6c56"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for field 'reason'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java",
      "language": "JAVA",
      "line": 210,
      "offset": 17,
      "length": 16,
      "code": {
        "startLine": 208,
        "length": 16,
        "offset": 50,
        "surroundingCode": "\n\t\tprivate final boolean skipped;\n\t\tprivate final Optional<String> reason;\n\n\t\t/**"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-engine.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "908cc405a0c651ab49a6a4ab98731d499719c3988b34679f543c4a835fb81bd7"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'element'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java",
      "language": "JAVA",
      "line": 99,
      "offset": 66,
      "length": 36,
      "code": {
        "startLine": 97,
        "length": 36,
        "offset": 164,
        "surroundingCode": "\t * @see org.junit.platform.commons.support.AnnotationSupport#findAnnotation(Optional, Class)\n\t */\n\tpublic static <A extends Annotation> Optional<A> findAnnotation(Optional<? extends AnnotatedElement> element,\n\t\t\tClass<A> annotationType) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "c9257d93970e880100910ca3b02d33aff256b6dc47417c3a28b7f38af5897307"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'element'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java",
      "language": "JAVA",
      "line": 190,
      "offset": 73,
      "length": 36,
      "code": {
        "startLine": 188,
        "length": 36,
        "offset": 182,
        "surroundingCode": "\t * @see org.junit.platform.commons.support.AnnotationSupport#findRepeatableAnnotations(Optional, Class)\n\t */\n\tpublic static <A extends Annotation> List<A> findRepeatableAnnotations(Optional<? extends AnnotatedElement> element,\n\t\t\tClass<A> annotationType) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "c2251a98f71658c306622ee7f1a98d15aa33313bd8d8e67688370e729632e947"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'element'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java",
      "language": "JAVA",
      "line": 74,
      "offset": 36,
      "length": 36,
      "code": {
        "startLine": 72,
        "length": 36,
        "offset": 131,
        "surroundingCode": "\t * @see org.junit.platform.commons.support.AnnotationSupport#isAnnotated(Optional, Class)\n\t */\n\tpublic static boolean isAnnotated(Optional<? extends AnnotatedElement> element,\n\t\t\tClass<? extends Annotation> annotationType) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "a85fecca28bb67f8d89fd721b5b362e14d19e7deea023e3f00f51a038e4e4b75"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'element'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/support/AnnotationSupport.java",
      "language": "JAVA",
      "line": 149,
      "offset": 73,
      "length": 36,
      "code": {
        "startLine": 147,
        "length": 36,
        "offset": 119,
        "surroundingCode": "\t */\n\t@API(status = MAINTAINED, since = \"1.5\")\n\tpublic static <A extends Annotation> List<A> findRepeatableAnnotations(Optional<? extends AnnotatedElement> element,\n\t\t\tClass<A> annotationType) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "b3d9b523ced914fab7bf2b3cf0d5f94eab420e9aa6f2a26d91bfbcf78ab96bcb"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'element'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/support/AnnotationSupport.java",
      "language": "JAVA",
      "line": 102,
      "offset": 66,
      "length": 36,
      "code": {
        "startLine": 100,
        "length": 36,
        "offset": 112,
        "surroundingCode": "\t */\n\t@API(status = MAINTAINED, since = \"1.1\")\n\tpublic static <A extends Annotation> Optional<A> findAnnotation(Optional<? extends AnnotatedElement> element,\n\t\t\tClass<A> annotationType) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "05d834a1b13726b23e3f2d9a84795afd866170e072f82f1becaf691f6dd3f00d"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'element'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/support/AnnotationSupport.java",
      "language": "JAVA",
      "line": 65,
      "offset": 36,
      "length": 36,
      "code": {
        "startLine": 63,
        "length": 36,
        "offset": 82,
        "surroundingCode": "\t */\n\t@API(status = MAINTAINED, since = \"1.3\")\n\tpublic static boolean isAnnotated(Optional<? extends AnnotatedElement> element,\n\t\t\tClass<? extends Annotation> annotationType) {\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "592fa2903ea4242ef1895a9c5471f1bce543472dd38a75a4b08058677bf55c35"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'customClassLoader'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-console/src/main/java/org/junit/platform/console/tasks/CustomContextClassLoaderExecutor.java",
      "language": "JAVA",
      "line": 23,
      "offset": 35,
      "length": 21,
      "code": {
        "startLine": 21,
        "length": 21,
        "offset": 91,
        "surroundingCode": "\tprivate final Optional<ClassLoader> customClassLoader;\n\n\tCustomContextClassLoaderExecutor(Optional<ClassLoader> customClassLoader) {\n\t\tthis.customClassLoader = customClassLoader;\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-console.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "bd7615dbb9c3330fc4353f547fff7fd3e888336a2e3ee2b921e2d380794a9d32"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for field 'customClassLoader'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-console/src/main/java/org/junit/platform/console/tasks/CustomContextClassLoaderExecutor.java",
      "language": "JAVA",
      "line": 21,
      "offset": 16,
      "length": 21,
      "code": {
        "startLine": 19,
        "length": 21,
        "offset": 57,
        "surroundingCode": "class CustomContextClassLoaderExecutor {\n\n\tprivate final Optional<ClassLoader> customClassLoader;\n\n\tCustomContextClassLoaderExecutor(Optional<ClassLoader> customClassLoader) {"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-console.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "74a119b4bedad89d3741092fd5316d3a417021d4fc4bfc4d60917e0b4939f333"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'stdoutInterceptor'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/StreamInterceptingTestExecutionListener.java",
      "language": "JAVA",
      "line": 66,
      "offset": 50,
      "length": 27,
      "code": {
        "startLine": 64,
        "length": 27,
        "offset": 53,
        "surroundingCode": "\t}\n\n\tprivate StreamInterceptingTestExecutionListener(Optional<StreamInterceptor> stdoutInterceptor,\n\t\t\tOptional<StreamInterceptor> stderrInterceptor, BiConsumer<TestIdentifier, ReportEntry> reporter) {\n\t\tthis.stdoutInterceptor = stdoutInterceptor;"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "d505e7781fa9f1a3ee7f3c80a33e8f5439492ca33020d72da7dcd561083986cd"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'stderrInterceptor'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/StreamInterceptingTestExecutionListener.java",
      "language": "JAVA",
      "line": 67,
      "offset": 4,
      "length": 27,
      "code": {
        "startLine": 65,
        "length": 27,
        "offset": 100,
        "surroundingCode": "\n\tprivate StreamInterceptingTestExecutionListener(Optional<StreamInterceptor> stdoutInterceptor,\n\t\t\tOptional<StreamInterceptor> stderrInterceptor, BiConsumer<TestIdentifier, ReportEntry> reporter) {\n\t\tthis.stdoutInterceptor = stdoutInterceptor;\n\t\tthis.stderrInterceptor = stderrInterceptor;"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "1688b5b7eeee72787a353dea51378030bc684ae03aabd14804d90793f65006fc"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for field 'stdoutInterceptor'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/StreamInterceptingTestExecutionListener.java",
      "language": "JAVA",
      "line": 37,
      "offset": 16,
      "length": 27,
      "code": {
        "startLine": 35,
        "length": 27,
        "offset": 102,
        "surroundingCode": "class StreamInterceptingTestExecutionListener implements EagerTestExecutionListener {\n\n\tprivate final Optional<StreamInterceptor> stdoutInterceptor;\n\tprivate final Optional<StreamInterceptor> stderrInterceptor;\n\tprivate final BiConsumer<TestIdentifier, ReportEntry> reporter;"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "ad02cba0eb87f5fb92dbedf32646e805c001cf2e6f72013e1cf42a113984a367"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for field 'stderrInterceptor'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/StreamInterceptingTestExecutionListener.java",
      "language": "JAVA",
      "line": 38,
      "offset": 16,
      "length": 27,
      "code": {
        "startLine": 36,
        "length": 27,
        "offset": 78,
        "surroundingCode": "\n\tprivate final Optional<StreamInterceptor> stdoutInterceptor;\n\tprivate final Optional<StreamInterceptor> stderrInterceptor;\n\tprivate final BiConsumer<TestIdentifier, ReportEntry> reporter;\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "ff34c81a46ae68acd4550e55b0e84de2e84d86165e5e9f5b0c350976380f811a"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'reason'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryOrchestrator.java",
      "language": "JAVA",
      "line": 132,
      "offset": 44,
      "length": 16,
      "code": {
        "startLine": 130,
        "length": 16,
        "offset": 47,
        "surroundingCode": "\t}\n\n\tprivate void populateExclusionReasonInMap(Optional<String> reason, TestDescriptor testDescriptor,\n\t\t\tMap<String, List<TestDescriptor>> excludedTestDescriptorsByReason) {\n\t\texcludedTestDescriptorsByReason.computeIfAbsent(reason.orElse(\"Unknown\"), list -> new LinkedList<>()).add("
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "4f30e82fdf9902332376de42bcd5bbc8f4e87dd9d35bee7ddd96653c3c885f9a"
},{
  "tool": "Code Inspection",
  "category": "Abstraction issues",
  "type": "'Optional' used as field or parameter type",
  "severity": "High",
  "comment": "'Optional' used as type for parameter 'testIdentifier'",
  "detailsInfo": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/XmlReportData.java",
      "language": "JAVA",
      "line": 129,
      "offset": 48,
      "length": 24,
      "code": {
        "startLine": 127,
        "length": 24,
        "offset": 51,
        "surroundingCode": "\t}\n\n\tprivate Optional<TestIdentifier> findAncestor(Optional<TestIdentifier> testIdentifier,\n\t\t\tPredicate<TestIdentifier> predicate) {\n\t\tOptional<TestIdentifier> current = testIdentifier;"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-reporting.main",
    "inspectionName": "OptionalUsedAsFieldOrParameterType"
  },
  "hash": "72d978f83bbc01085ddb0e1c9e53f6e97b79cf04d2c58f5de21e8bce1b07cbd3"
},{
  "tool": "Code Inspection",
  "category": "Resource management",
  "type": "I/O resource opened but not safely closed",
  "severity": "High",
  "comment": "'InputStream' should be opened in front of a 'try' block and closed in the corresponding 'finally' block",
  "detailsInfo": "Reports I/O resources that are not safely closed. I/O resources checked by this inspection include `java.io.InputStream`, `java.io.OutputStream`, `java.io.Reader`, `java.io.Writer`, `java.util.zip.ZipFile`, `java.io.Closeable` and `java.io.RandomAccessFile`.\n\n\nI/O resources wrapped by other I/O resources are not reported, as the wrapped resource will be closed by the wrapping resource.\n\n\nBy default, the inspection assumes that the resources can be closed by any method with\n'close' or 'cleanup' in its name.\n\n**Example:**\n\n\n      void save() throws IOException {\n        FileWriter writer = new FileWriter(\"filename.txt\"); //warning\n        writer.write(\"sample\");\n      }\n\n\nUse the following options to configure the inspection:\n\n* List I/O resource classes that do not need to be closed and should be ignored by this inspection.\n* Whether an I/O resource is allowed to be opened inside a `try`block. This style is less desirable because it is more verbose than opening a resource in front of a `try` block.\n* Whether the resource can be closed by any method call with the resource passed as argument.",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java",
      "language": "JAVA",
      "line": 193,
      "offset": 40,
      "length": 19,
      "code": {
        "startLine": 191,
        "length": 19,
        "offset": 219,
        "surroundingCode": "\t\tpublic InputStream openClasspathResource(Class<?> baseClass, String path) {\n\t\t\tPreconditions.notBlank(path, () -> \"Classpath resource [\" + path + \"] must not be null or blank\");\n\t\t\tInputStream inputStream = baseClass.getResourceAsStream(path);\n\t\t\treturn Preconditions.notNull(inputStream, () -> \"Classpath resource [\" + path + \"] does not exist\");\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-params.main",
    "inspectionName": "IOResource"
  },
  "hash": "49ca7ff7b4d85280aa62ad0fe69e9e73bf5d0292318cda83b7ca118a1ce630bd"
},{
  "tool": "Code Inspection",
  "category": "Java interop issues",
  "type": "Function or property has platform type",
  "severity": "Moderate",
  "comment": "Declaration has type inferred from a platform call, which can lead to unchecked nullability issues. Specify type explicitly as nullable or non-nullable.",
  "detailsInfo": "Reports functions and properties that have a platform type.\n\nTo prevent unexpected errors, the type should be declared explicitly.\n\n**Example:**\n\n\n      fun foo() = java.lang.String.valueOf(1)\n\nThe quick fix allows you to specify the return type:\n\n\n      fun foo(): String = java.lang.String.valueOf(1)\n",
  "sources": [
    {
      "type": "file",
      "path": "build.gradle.kts",
      "language": "kotlin",
      "line": 30,
      "offset": 5,
      "length": 16,
      "code": {
        "startLine": 28,
        "length": 16,
        "offset": 7,
        "surroundingCode": "}\n\nval buildTimeAndDate by extra {\n\n\t// SOURCE_DATE_EPOCH is a UNIX timestamp for pinning build metadata against"
      }
    }
  ],
  "attributes": {
    "module": "junit5",
    "inspectionName": "HasPlatformType"
  },
  "hash": "f31631da71b1cdf1ecde989663509ce1c7e361d95769ff2def60ecbefdbc73b2"
},{
  "tool": "Code Inspection",
  "category": "Java interop issues",
  "type": "Function or property has platform type",
  "severity": "Moderate",
  "comment": "Declaration has type inferred from a platform call, which can lead to unchecked nullability issues. Specify type explicitly as nullable or non-nullable.",
  "detailsInfo": "Reports functions and properties that have a platform type.\n\nTo prevent unexpected errors, the type should be declared explicitly.\n\n**Example:**\n\n\n      fun foo() = java.lang.String.valueOf(1)\n\nThe quick fix allows you to specify the return type:\n\n\n      fun foo(): String = java.lang.String.valueOf(1)\n",
  "sources": [
    {
      "type": "file",
      "path": "build.gradle.kts",
      "language": "kotlin",
      "line": 48,
      "offset": 5,
      "length": 9,
      "code": {
        "startLine": 46,
        "length": 9,
        "offset": 7,
        "surroundingCode": "}\n\nval buildDate by extra { DateTimeFormatter.ISO_LOCAL_DATE.format(buildTimeAndDate) }\nval buildTime by extra { DateTimeFormatter.ofPattern(\"HH:mm:ss.SSSZ\").format(buildTimeAndDate) }\nval buildRevision by extra { versioning.info.commit }"
      }
    }
  ],
  "attributes": {
    "module": "junit5",
    "inspectionName": "HasPlatformType"
  },
  "hash": "5559152d8016719dd1acef7e8569eba37ce254d8fbfd67cfe0202cf6299dab91"
},{
  "tool": "Code Inspection",
  "category": "Java interop issues",
  "type": "Function or property has platform type",
  "severity": "Moderate",
  "comment": "Declaration has type inferred from a platform call, which can lead to unchecked nullability issues. Specify type explicitly as nullable or non-nullable.",
  "detailsInfo": "Reports functions and properties that have a platform type.\n\nTo prevent unexpected errors, the type should be declared explicitly.\n\n**Example:**\n\n\n      fun foo() = java.lang.String.valueOf(1)\n\nThe quick fix allows you to specify the return type:\n\n\n      fun foo(): String = java.lang.String.valueOf(1)\n",
  "sources": [
    {
      "type": "file",
      "path": "build.gradle.kts",
      "language": "kotlin",
      "line": 49,
      "offset": 5,
      "length": 9,
      "code": {
        "startLine": 47,
        "length": 9,
        "offset": 90,
        "surroundingCode": "\nval buildDate by extra { DateTimeFormatter.ISO_LOCAL_DATE.format(buildTimeAndDate) }\nval buildTime by extra { DateTimeFormatter.ofPattern(\"HH:mm:ss.SSSZ\").format(buildTimeAndDate) }\nval buildRevision by extra { versioning.info.commit }\nval builtByValue by extra { project.findProperty(\"builtBy\") ?: project.property(\"defaultBuiltBy\") }"
      }
    }
  ],
  "attributes": {
    "module": "junit5",
    "inspectionName": "HasPlatformType"
  },
  "hash": "0e345d5424b39dfc88569456841e69ddf712c6d1c27bb0098039ecdc05e4e0db"
},{
  "tool": "Code Inspection",
  "category": "Java interop issues",
  "type": "Function or property has platform type",
  "severity": "Moderate",
  "comment": "Declaration has type inferred from a platform call, which can lead to unchecked nullability issues. Specify type explicitly as nullable or non-nullable.",
  "detailsInfo": "Reports functions and properties that have a platform type.\n\nTo prevent unexpected errors, the type should be declared explicitly.\n\n**Example:**\n\n\n      fun foo() = java.lang.String.valueOf(1)\n\nThe quick fix allows you to specify the return type:\n\n\n      fun foo(): String = java.lang.String.valueOf(1)\n",
  "sources": [
    {
      "type": "file",
      "path": "build.gradle.kts",
      "language": "kotlin",
      "line": 50,
      "offset": 5,
      "length": 13,
      "code": {
        "startLine": 48,
        "length": 13,
        "offset": 186,
        "surroundingCode": "val buildDate by extra { DateTimeFormatter.ISO_LOCAL_DATE.format(buildTimeAndDate) }\nval buildTime by extra { DateTimeFormatter.ofPattern(\"HH:mm:ss.SSSZ\").format(buildTimeAndDate) }\nval buildRevision by extra { versioning.info.commit }\nval builtByValue by extra { project.findProperty(\"builtBy\") ?: project.property(\"defaultBuiltBy\") }\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5",
    "inspectionName": "HasPlatformType"
  },
  "hash": "33f12d24d38ed0bb9a35370141ada4ce368ad189b0cdfeb2bd5ad0a049b5a46c"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'SingleTestExecutor' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/SingleTestExecutor.java",
      "language": "JAVA",
      "line": 34,
      "offset": 14,
      "length": 18,
      "code": {
        "startLine": 32,
        "length": 18,
        "offset": 66,
        "surroundingCode": "@Deprecated\n@API(status = DEPRECATED, since = \"1.2\")\npublic class SingleTestExecutor {\n\n\t/**"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-engine.main",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "48947bc96c05c7b7d079051317203e48c0f713c1e3f21db783870e78775bbbfc"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'readFieldValue' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 537,
      "offset": 37,
      "length": 14,
      "code": {
        "startLine": 535,
        "length": 14,
        "offset": 91,
        "surroundingCode": "\t@API(status = DEPRECATED, since = \"1.4\")\n\t@Deprecated\n\tpublic static <T> Optional<Object> readFieldValue(Class<T> clazz, String fieldName, T instance) {\n\t\treturn tryToReadFieldValue(clazz, fieldName, instance).toOptional();\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "6e08cf19e100fa79f22ba53b101d3211a3f0e09d151f8d8687ff778ba370de50"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'readFieldValue' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 619,
      "offset": 33,
      "length": 14,
      "code": {
        "startLine": 617,
        "length": 14,
        "offset": 87,
        "surroundingCode": "\t@API(status = DEPRECATED, since = \"1.4\")\n\t@Deprecated\n\tpublic static Optional<Object> readFieldValue(Field field, Object instance) {\n\t\treturn tryToReadFieldValue(field, instance).toOptional();\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "5ebb58c51699bd974f170d3cbd2a699205e859699872b53c9d0a9f010d0b5bcb"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'readFieldValue' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 581,
      "offset": 33,
      "length": 14,
      "code": {
        "startLine": 579,
        "length": 14,
        "offset": 87,
        "surroundingCode": "\t@API(status = DEPRECATED, since = \"1.4\")\n\t@Deprecated\n\tpublic static Optional<Object> readFieldValue(Field field) {\n\t\treturn tryToReadFieldValue(field).toOptional();\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "31a3e8a666d23be096ea607e5eaea59edee2efada26221f1e0f98917ef23dde1"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'getOutermostInstance' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 906,
      "offset": 33,
      "length": 20,
      "code": {
        "startLine": 904,
        "length": 20,
        "offset": 87,
        "surroundingCode": "\t@API(status = DEPRECATED, since = \"1.4\")\n\t@Deprecated\n\tpublic static Optional<Object> getOutermostInstance(Object inner, Class<?> requiredType) {\n\t\tPreconditions.notNull(inner, \"inner object must not be null\");\n\t\tPreconditions.notNull(requiredType, \"requiredType must not be null\");"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "c5882be021eb335d0d3c6569351c43f653cb0c162af7cfdf7cfc8b4d158015a7"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'loadClass' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 701,
      "offset": 35,
      "length": 9,
      "code": {
        "startLine": 699,
        "length": 9,
        "offset": 89,
        "surroundingCode": "\t@API(status = DEPRECATED, since = \"1.4\")\n\t@Deprecated\n\tpublic static Optional<Class<?>> loadClass(String name) {\n\t\treturn tryToLoadClass(name).toOptional();\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "2fd43729e472e0cad094fc82df08fb75c017926a4735356f32159edfd6695ca7"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'loadClass' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
      "language": "JAVA",
      "line": 69,
      "offset": 35,
      "length": 9,
      "code": {
        "startLine": 67,
        "length": 9,
        "offset": 81,
        "surroundingCode": "\t@Deprecated\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static Optional<Class<?>> loadClass(String name) {\n\t\treturn ReflectionUtils.loadClass(name);\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "1d4504d232376af6d7f34a6946e68b4c32a9bc440a0525a419b11411c6b24eaa"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'LegacyReportingUtils' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/LegacyReportingUtils.java",
      "language": "JAVA",
      "line": 31,
      "offset": 14,
      "length": 20,
      "code": {
        "startLine": 29,
        "length": 20,
        "offset": 66,
        "surroundingCode": "@Deprecated\n@API(status = DEPRECATED, since = \"1.6\")\npublic class LegacyReportingUtils {\n\n\tprivate LegacyReportingUtils() {"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "b30add5fc37bf834d38c807acd7ed64123bcadc8492c59874b1c51085ee540ae"
},{
  "tool": "Code Inspection",
  "category": "RegExp",
  "type": "Redundant character escape",
  "severity": "High",
  "comment": "Redundant character escape ']' in RegExp",
  "detailsInfo": "Reports redundant character escape sequences that can be replaced with unescaped characters preserving the meaning. Many escape sequences that are necessary outside of a character class are redundant inside square brackets `[]` of a character class.\n\n\nAlthough unescaped opening curly braces `{` outside of character classes are allowed in some dialects (JavaScript, Python, and so on),\nit can cause confusion and make the pattern less portable, because there are dialects that require escaping curly braces as characters.\nFor this reason the inspection does not report escaped opening curly braces.\n\n**Example:**\n\n\n      \\-\\;[\\.]\n\nAfter the quick-fix is applied:\n\n\n      -;[.]\n\n\nThe **Ignore escaped closing brackets '}' and '\\]'** option specifies whether to report `\\}` and `\\]` outside of a character class\nwhen they are allowed to be unescaped by the RegExp dialect.\n\nNew in 2017.3",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "RegExp",
      "line": 118,
      "offset": 101,
      "length": 3,
      "code": {
        "startLine": 116,
        "length": 3,
        "offset": 165,
        "surroundingCode": "\n\t// Pattern: \"java.lang.String[]\", \"int[]\", \"int[][][][]\", etc.\n\tprivate static final Pattern SOURCE_CODE_SYNTAX_ARRAY_PATTERN = Pattern.compile(\"^([^\\\\[\\\\]]+)((\\\\[\\\\])+)+$\");\n\n\tprivate static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "RegExpRedundantEscape"
  },
  "hash": "0c828f3a2350c25f7cb344b25684917cc58316c752e3504306b67756e81e1178"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Duplicate branches in 'switch'",
  "severity": "Moderate",
  "comment": "Branch in 'switch' is a duplicate of the default branch",
  "detailsInfo": "Reports `switch` statements or expressions that contain the same code in different branches and suggests merging the duplicate branches.\n\nExample:\n\n\n      switch (n) {\n        case 1:\n          System.out.println(n);\n          break;\n        case 2:\n          System.out.println(n);\n          break;\n        default:\n          System.out.println(\"default\");\n      }\n\nCan be replaced with:\n\n\n      switch (n) {\n        case 1:\n        case 2:\n          System.out.println(n);\n          break;\n        default:\n          System.out.println(\"default\");\n      }\n\nNew in 2019.1",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-console/src/main/java/org/junit/platform/console/tasks/ConsoleTestExecutor.java",
      "language": "JAVA",
      "line": 113,
      "offset": 5,
      "length": 24,
      "code": {
        "startLine": 111,
        "length": 24,
        "offset": 78,
        "surroundingCode": "\t\t\tcase SUMMARY:\n\t\t\t\t// summary listener is always created and registered\n\t\t\t\treturn Optional.empty();\n\t\t\tcase FLAT:\n\t\t\t\treturn Optional.of(new FlatPrintingListener(out, disableAnsiColors));"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-console.main",
    "inspectionName": "DuplicateBranchesInSwitch"
  },
  "hash": "bddc6022dd86b2ac0d58a55844cdfb350adbdb13028fe5c666c1571961a399eb"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Array comparison using '==', instead of 'Arrays.equals()'",
  "severity": "High",
  "comment": "Array objects are compared using '==', not 'Arrays.equals()'",
  "detailsInfo": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertArrayEquals.java",
      "language": "JAVA",
      "line": 301,
      "offset": 16,
      "length": 2,
      "code": {
        "startLine": 299,
        "length": 2,
        "offset": 47,
        "surroundingCode": "\t\t\tObject messageOrSupplier) {\n\n\t\tif (expected == actual) {\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ArrayEquality"
  },
  "hash": "360474050579ec684bdfc6696e9cf1dc90d777c493d85a6d746b5a5ab237bba3"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Array comparison using '==', instead of 'Arrays.equals()'",
  "severity": "High",
  "comment": "Array objects are compared using '==', not 'Arrays.equals()'",
  "detailsInfo": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertArrayEquals.java",
      "language": "JAVA",
      "line": 318,
      "offset": 16,
      "length": 2,
      "code": {
        "startLine": 316,
        "length": 2,
        "offset": 58,
        "surroundingCode": "\n\t\tAssertionUtils.assertValidDelta(delta);\n\t\tif (expected == actual) {\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ArrayEquality"
  },
  "hash": "8fa604c797236f24fa50224d32f8e9210fd5467050e5c6782075aab6b48dcef8"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Array comparison using '==', instead of 'Arrays.equals()'",
  "severity": "High",
  "comment": "Array objects are compared using '==', not 'Arrays.equals()'",
  "detailsInfo": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertArrayEquals.java",
      "language": "JAVA",
      "line": 172,
      "offset": 16,
      "length": 2,
      "code": {
        "startLine": 170,
        "length": 2,
        "offset": 47,
        "surroundingCode": "\t\t\tObject messageOrSupplier) {\n\n\t\tif (expected == actual) {\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ArrayEquality"
  },
  "hash": "8b3879e71acb57d94f4a618e0438856a66200fd3eaddbad9f1e465e4e61d0487"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Array comparison using '==', instead of 'Arrays.equals()'",
  "severity": "High",
  "comment": "Array objects are compared using '==', not 'Arrays.equals()'",
  "detailsInfo": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertArrayEquals.java",
      "language": "JAVA",
      "line": 285,
      "offset": 16,
      "length": 2,
      "code": {
        "startLine": 283,
        "length": 2,
        "offset": 58,
        "surroundingCode": "\n\t\tAssertionUtils.assertValidDelta(delta);\n\t\tif (expected == actual) {\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ArrayEquality"
  },
  "hash": "15c384b27248b4cc784cf5f730a86ed01fbb3b18da7511b42d154b3e65f6a310"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Array comparison using '==', instead of 'Arrays.equals()'",
  "severity": "High",
  "comment": "Array objects are compared using '==', not 'Arrays.equals()'",
  "detailsInfo": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertArrayEquals.java",
      "language": "JAVA",
      "line": 268,
      "offset": 16,
      "length": 2,
      "code": {
        "startLine": 266,
        "length": 2,
        "offset": 47,
        "surroundingCode": "\t\t\tObject messageOrSupplier) {\n\n\t\tif (expected == actual) {\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ArrayEquality"
  },
  "hash": "394b544b5c3b087b3be8b1b84082c06c58d0c9a35a0cf1dd382b30be8fe12caf"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Array comparison using '==', instead of 'Arrays.equals()'",
  "severity": "High",
  "comment": "Array objects are compared using '==', not 'Arrays.equals()'",
  "detailsInfo": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertArrayEquals.java",
      "language": "JAVA",
      "line": 220,
      "offset": 16,
      "length": 2,
      "code": {
        "startLine": 218,
        "length": 2,
        "offset": 47,
        "surroundingCode": "\t\t\tObject messageOrSupplier) {\n\n\t\tif (expected == actual) {\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ArrayEquality"
  },
  "hash": "199655e5aa3a3dc740fb046b2df97ac29aa7a558a2d6015a2b30e80241063c73"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Array comparison using '==', instead of 'Arrays.equals()'",
  "severity": "High",
  "comment": "Array objects are compared using '==', not 'Arrays.equals()'",
  "detailsInfo": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertArrayEquals.java",
      "language": "JAVA",
      "line": 188,
      "offset": 16,
      "length": 2,
      "code": {
        "startLine": 186,
        "length": 2,
        "offset": 47,
        "surroundingCode": "\t\t\tObject messageOrSupplier) {\n\n\t\tif (expected == actual) {\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ArrayEquality"
  },
  "hash": "ec9fbdf400ec12f427486f45c67dfd504ce68c42dd4a3cd40d5666c2fa28b042"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Array comparison using '==', instead of 'Arrays.equals()'",
  "severity": "High",
  "comment": "Array objects are compared using '==', not 'Arrays.equals()'",
  "detailsInfo": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertArrayEquals.java",
      "language": "JAVA",
      "line": 252,
      "offset": 16,
      "length": 2,
      "code": {
        "startLine": 250,
        "length": 2,
        "offset": 47,
        "surroundingCode": "\t\t\tObject messageOrSupplier) {\n\n\t\tif (expected == actual) {\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ArrayEquality"
  },
  "hash": "ee472bb8645cd85b27ec7e897d3a1cb83d70102f00d9a612e99aed4958421601"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Array comparison using '==', instead of 'Arrays.equals()'",
  "severity": "High",
  "comment": "Array objects are compared using '==', not 'Arrays.equals()'",
  "detailsInfo": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertArrayEquals.java",
      "language": "JAVA",
      "line": 236,
      "offset": 16,
      "length": 2,
      "code": {
        "startLine": 234,
        "length": 2,
        "offset": 47,
        "surroundingCode": "\t\t\tObject messageOrSupplier) {\n\n\t\tif (expected == actual) {\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ArrayEquality"
  },
  "hash": "f1606401522774519b40628990f240c3a1b24e30bc0501a987083f426e607a66"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Array comparison using '==', instead of 'Arrays.equals()'",
  "severity": "High",
  "comment": "Array objects are compared using '==', not 'Arrays.equals()'",
  "detailsInfo": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertArrayEquals.java",
      "language": "JAVA",
      "line": 204,
      "offset": 16,
      "length": 2,
      "code": {
        "startLine": 202,
        "length": 2,
        "offset": 47,
        "surroundingCode": "\t\t\tObject messageOrSupplier) {\n\n\t\tif (expected == actual) {\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ArrayEquality"
  },
  "hash": "da083b35ba449520b66a13cf560976a0933bc1affdebd30c15c5b38c731084ea"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Array comparison using '==', instead of 'Arrays.equals()'",
  "severity": "High",
  "comment": "Array objects are compared using '==', not 'Arrays.equals()'",
  "detailsInfo": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertArrayEquals.java",
      "language": "JAVA",
      "line": 334,
      "offset": 16,
      "length": 2,
      "code": {
        "startLine": 332,
        "length": 2,
        "offset": 47,
        "surroundingCode": "\t\t\tObject messageOrSupplier) {\n\n\t\tif (expected == actual) {\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ArrayEquality"
  },
  "hash": "a85e73d9b831fedd3ab66002e6d1fc2c17b2f2efc310b126562f1784ab95f4eb"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Redundant 'Collection.addAll()' call",
  "severity": "High",
  "comment": "'addAll()' call can be replaced with parametrized constructor call",
  "detailsInfo": "Reports `Collection.addAll()` and `Map.putAll()` calls immediately after instantiation of a collection using the no-arg constructor.\n\nSuch constructs can be replaced with a single call to a parametrized constructor, which simplifies code. Also, for some collections the replacement\nmight be more performant.\n\n**Example:**\n\n      Set<String> set = new HashSet<>();\n      set.addAll(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\nCan be replaced with:\n\n      Set<String> set = new HashSet<>(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\n\nStandard JDK collection classes are supported by default. Additionally, you can specify other classes in the inspection options.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/TestDescriptor.java",
      "language": "JAVA",
      "line": 119,
      "offset": 15,
      "length": 6,
      "code": {
        "startLine": 117,
        "length": 6,
        "offset": 131,
        "surroundingCode": "\tdefault Set<? extends TestDescriptor> getDescendants() {\n\t\tSet<TestDescriptor> descendants = new LinkedHashSet<>();\n\t\tdescendants.addAll(getChildren());\n\t\tfor (TestDescriptor child : getChildren()) {\n\t\t\tdescendants.addAll(child.getDescendants());"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-engine.main",
    "inspectionName": "CollectionAddAllCanBeReplacedWithConstructor"
  },
  "hash": "6cd8dd765c49855197b4cffeed49f7e8b1c93a3bd3fe164b389bb47c6f4a3da6"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Call to default 'toString()'",
  "severity": "High",
  "comment": "Call to default 'toString()' on 'testPlan'",
  "detailsInfo": "Reports calls to `toString()` that use the default implementation from `java.lang.Object`.\n\nThe default implementation is rarely intended but may be used by accident.\n\n\nCalls to `toString()` on objects with `java.lang.Object`,\ninterface or abstract class type are ignored by this inspection.\n\n**Example:**\n\n\n      class Bar {\n          void foo1(Bar bar) {\n              String s = bar.toString(); // warning\n              /* ... */\n          }\n\n          void foo2(Object obj) {\n              String s = obj.toString(); // no warning here\n              /* ... */\n          }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-console/src/main/java/org/junit/platform/console/tasks/TreePrintingListener.java",
      "language": "JAVA",
      "line": 51,
      "offset": 23,
      "length": 8,
      "code": {
        "startLine": 49,
        "length": 8,
        "offset": 92,
        "surroundingCode": "\t@Override\n\tpublic void testPlanExecutionStarted(TestPlan testPlan) {\n\t\troot = new TreeNode(testPlan.toString());\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-console.main",
    "inspectionName": "ObjectToString"
  },
  "hash": "8b919c69eeef73814e5889fc101ee9fcb41ed2130ec8b2c3b8e332f032cfd499"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Call to default 'toString()'",
  "severity": "High",
  "comment": "Call to default 'toString()' on 'testPlan'",
  "detailsInfo": "Reports calls to `toString()` that use the default implementation from `java.lang.Object`.\n\nThe default implementation is rarely intended but may be used by accident.\n\n\nCalls to `toString()` on objects with `java.lang.Object`,\ninterface or abstract class type are ignored by this inspection.\n\n**Example:**\n\n\n      class Bar {\n          void foo1(Bar bar) {\n              String s = bar.toString(); // warning\n              /* ... */\n          }\n\n          void foo2(Object obj) {\n              String s = obj.toString(); // no warning here\n              /* ... */\n          }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/TestExecutionListenerRegistry.java",
      "language": "JAVA",
      "line": 122,
      "offset": 42,
      "length": 8,
      "code": {
        "startLine": 120,
        "length": 8,
        "offset": 198,
        "surroundingCode": "\t\tpublic void testPlanExecutionFinished(TestPlan testPlan) {\n\t\t\tnotifyEach(testExecutionListeners, listener -> listener.testPlanExecutionFinished(testPlan),\n\t\t\t\t() -> \"testPlanExecutionFinished(\" + testPlan + \")\");\n\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "ObjectToString"
  },
  "hash": "c59fa6d313474724e75e32fe3e1ca7380533e8c240c12c6f40bfc8744814b4bf"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Call to default 'toString()'",
  "severity": "High",
  "comment": "Call to default 'toString()' on 'testPlan'",
  "detailsInfo": "Reports calls to `toString()` that use the default implementation from `java.lang.Object`.\n\nThe default implementation is rarely intended but may be used by accident.\n\n\nCalls to `toString()` on objects with `java.lang.Object`,\ninterface or abstract class type are ignored by this inspection.\n\n**Example:**\n\n\n      class Bar {\n          void foo1(Bar bar) {\n              String s = bar.toString(); // warning\n              /* ... */\n          }\n\n          void foo2(Object obj) {\n              String s = obj.toString(); // no warning here\n              /* ... */\n          }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/TestExecutionListenerRegistry.java",
      "language": "JAVA",
      "line": 116,
      "offset": 41,
      "length": 8,
      "code": {
        "startLine": 114,
        "length": 8,
        "offset": 195,
        "surroundingCode": "\t\tpublic void testPlanExecutionStarted(TestPlan testPlan) {\n\t\t\tnotifyEach(testExecutionListeners, listener -> listener.testPlanExecutionStarted(testPlan),\n\t\t\t\t() -> \"testPlanExecutionStarted(\" + testPlan + \")\");\n\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "ObjectToString"
  },
  "hash": "58ecf181aedf00c42e1c8513e9543d47c843cf05c32f500c73386e821453dffd"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(throwable)' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java",
      "language": "JAVA",
      "line": 135,
      "offset": 12,
      "length": 51,
      "code": {
        "startLine": 133,
        "length": 51,
        "offset": 51,
        "surroundingCode": "\t\t\t\t}\n\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\tthrow ExceptionUtils.throwAsUncheckedException(throwable);\n\t\t\t\t}\n\t\t\t});"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "a559b8d9dd3da28db6499e0177812db639ddd9e3a28dbb34dbb5691966132ac3"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(ex.getCause())' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java",
      "language": "JAVA",
      "line": 148,
      "offset": 11,
      "length": 55,
      "code": {
        "startLine": 146,
        "length": 55,
        "offset": 50,
        "surroundingCode": "\t\t\t}\n\t\t\tcatch (ExecutionException ex) {\n\t\t\t\tthrow ExceptionUtils.throwAsUncheckedException(ex.getCause());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "9a87af6bc0550d063b7d917aafb4b847cec81ec04bc12a4bd5a091456ff10f26"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(ex)' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java",
      "language": "JAVA",
      "line": 151,
      "offset": 11,
      "length": 44,
      "code": {
        "startLine": 149,
        "length": 44,
        "offset": 41,
        "surroundingCode": "\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow ExceptionUtils.throwAsUncheckedException(ex);\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "32361a8fd2e41bbcaa6dda94d662068cb7c08744844ab105827c8bb026a6588a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation 'getActualTypeArguments' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/support/TypeBasedParameterResolver.java",
      "language": "JAVA",
      "line": 60,
      "offset": 47,
      "length": 22,
      "code": {
        "startLine": 58,
        "length": 22,
        "offset": 156,
        "surroundingCode": "\t\t\t\t\t\t+ \"potentially caused by lacking parameterized type in class declaration.\",\n\t\t\t\tgetClass().getName()));\n\t\treturn typeBasedParameterResolverSuperclass.getActualTypeArguments()[0];\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "5814703e1d6e56c577601c6811997c2439d21b69af7402a8f28a7875990d8f68"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(t)' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/InvocationInterceptorChain.java",
      "language": "JAVA",
      "line": 67,
      "offset": 10,
      "length": 43,
      "code": {
        "startLine": 65,
        "length": 43,
        "offset": 37,
        "surroundingCode": "\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(t);\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "57da655fcd45c64c6bfbd3759b99a4b9d813610fb255a7fdff1e5519f2ea52ba"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(e)' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java",
      "language": "JAVA",
      "line": 136,
      "offset": 10,
      "length": 43,
      "code": {
        "startLine": 134,
        "length": 43,
        "offset": 37,
        "surroundingCode": "\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(e);\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-params.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "00977ed92563393da77f5e777eaace7588585ec07874d7b99e8a3d3b433ad113"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "The call to 'assumeFalse' always fails, according to its method contracts",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/PlainJUnit4TestCaseWithFiveTestMethods.java",
      "language": "JAVA",
      "line": 36,
      "offset": 3,
      "length": 11,
      "code": {
        "startLine": 34,
        "length": 11,
        "offset": 38,
        "surroundingCode": "\t@Test\n\tpublic void abortedTest() {\n\t\tassumeFalse(\"this test should be aborted\", true);\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-vintage-engine.testFixtures",
    "inspectionName": "ConstantConditions"
  },
  "hash": "51159596e8b4b5f745759449eef54c6176163434a3ce1cfce0225c9b993755b7"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t))' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 1136,
      "offset": 10,
      "length": 63,
      "code": {
        "startLine": 1134,
        "length": 63,
        "offset": 37,
        "surroundingCode": "\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "3ec6a82388e19ccf80adb3b398daa26868650dc2bf28cefa36be648dbe729dd0"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t))' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 691,
      "offset": 10,
      "length": 63,
      "code": {
        "startLine": 689,
        "length": 63,
        "offset": 37,
        "surroundingCode": "\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "7ff31e107ea154e21ca045dabaefab3259bc0c6d6087176ba1001cbdf80a3c94"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t))' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 516,
      "offset": 10,
      "length": 63,
      "code": {
        "startLine": 514,
        "length": 63,
        "offset": 37,
        "surroundingCode": "\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "c0b084c8e8061f18e5ff1ee8aed4c3edd26f9b6f93f473a339a768a70aaa150a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t))' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 491,
      "offset": 10,
      "length": 63,
      "code": {
        "startLine": 489,
        "length": 63,
        "offset": 37,
        "surroundingCode": "\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "6ecd8a855d2499122add9058d1d37628c7992f702472ad4914e81c3b802ea8f8"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t))' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 1105,
      "offset": 10,
      "length": 63,
      "code": {
        "startLine": 1103,
        "length": 63,
        "offset": 37,
        "surroundingCode": "\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "72ced607eacf2ec6b0a255db125ba3e29a5c2f1156f39ada8ca6129c926c3297"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(t)' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 935,
      "offset": 13,
      "length": 43,
      "code": {
        "startLine": 933,
        "length": 43,
        "offset": 46,
        "surroundingCode": "\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\t\tthrow ExceptionUtils.throwAsUncheckedException(t);\n\t\t\t\t\t}\n\t\t\t\t});"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "f34e699055815c25bfb355c51ff3485256676dc35e036c1377136e5ccbdbd279"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "Moderate",
  "comment": "Value 'inherited' is always 'true'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java",
      "language": "JAVA",
      "line": 236,
      "offset": 75,
      "length": 9,
      "code": {
        "startLine": 234,
        "length": 9,
        "offset": 183,
        "surroundingCode": "\t\t\t\tClass<?> superclass = clazz.getSuperclass();\n\t\t\t\tif (superclass != null && superclass != Object.class) {\n\t\t\t\t\tfindRepeatableAnnotations(superclass, annotationType, containerType, inherited, found, visited);\n\t\t\t\t}\n\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "ffa9019b2a23cafa9b329395fd0fbf2b423b49b6e7a1c7bac1dcca3dc5b17a5a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "Moderate",
  "comment": "Value 'inherited' is always 'true'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java",
      "language": "JAVA",
      "line": 158,
      "offset": 86,
      "length": 9,
      "code": {
        "startLine": 156,
        "length": 9,
        "offset": 194,
        "surroundingCode": "\t\t\t\tClass<?> superclass = clazz.getSuperclass();\n\t\t\t\tif (superclass != null && superclass != Object.class) {\n\t\t\t\t\tOptional<A> annotationOnSuperclass = findAnnotation(superclass, annotationType, inherited, visited);\n\t\t\t\t\tif (annotationOnSuperclass.isPresent()) {\n\t\t\t\t\t\treturn annotationOnSuperclass;"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "4523d44aef6d6773ea6efee314464a854f75007b2a603b2156201f9f0f8b1e74"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument 'parentTrace' might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/MutableTestExecutionSummary.java",
      "language": "JAVA",
      "line": 251,
      "offset": 48,
      "length": 11,
      "code": {
        "startLine": 249,
        "length": 11,
        "offset": 114,
        "surroundingCode": "\t\t\twriter.printf(\"%s%s%s%n\", indentation, caption, throwable);\n\t\t}\n\t\tint duplicates = numberOfCommonFrames(trace, parentTrace);\n\t\tint numDistinctFrames = trace.length - duplicates;\n\t\tint numDisplayLines = (numDistinctFrames > max) ? max : numDistinctFrames;"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "833e5753c5ec8f04ba028398f412b2e1e21e7bdd886e819ca4120d23add7ca29"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of 'ExceptionUtils.throwAsUncheckedException(exception)' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-migrationsupport/src/main/java/org/junit/jupiter/migrationsupport/rules/member/TestRuleAnnotatedField.java",
      "language": "JAVA",
      "line": 37,
      "offset": 10,
      "length": 51,
      "code": {
        "startLine": 35,
        "length": 51,
        "offset": 58,
        "surroundingCode": "\t\t}\n\t\tcatch (IllegalAccessException exception) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(exception);\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-migrationsupport.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "75cdefc2c5035616b082daee8aa24fc240801d391c4373f2ae53ee43b1ab375f"
},{
  "tool": "Code Inspection",
  "category": "RegExp",
  "type": "Unnecessary non-capturing group",
  "severity": "High",
  "comment": "Unnecessary non-capturing group '(?:[nm]?s)'",
  "detailsInfo": "Reports unnecessary non-capturing groups, which have no influence on the match result.\n\n**Example:**\n\n\n      Everybody be cool, (?:this) is a robbery!\n\nAfter the quick-fix is applied:\n\n\n      Everybody be cool, this is a robbery!\n\nNew in 2021.1",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutDurationParser.java",
      "language": "RegExp",
      "line": 37,
      "offset": 72,
      "length": 3,
      "code": {
        "startLine": 35,
        "length": 3,
        "offset": 102,
        "surroundingCode": "class TimeoutDurationParser {\n\n\tprivate static final Pattern PATTERN = Pattern.compile(\"([1-9]\\\\d*) ?((?:[nm]?s)|m|h|d)?\",\n\t\tCASE_INSENSITIVE | UNICODE_CASE);\n\tprivate static final Map<String, TimeUnit> UNITS_BY_ABBREVIATION;"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "RegExpUnnecessaryNonCapturingGroup"
  },
  "hash": "590351ae6b1a5dc0b05548cfbbd352c3779da93e51df1e4a9897b4163131c92b"
},{
  "tool": "Code Inspection",
  "category": "RegExp",
  "type": "Unnecessary non-capturing group",
  "severity": "High",
  "comment": "Unnecessary non-capturing group '(?:(?:any|none)())'",
  "detailsInfo": "Reports unnecessary non-capturing groups, which have no influence on the match result.\n\n**Example:**\n\n\n      Everybody be cool, (?:this) is a robbery!\n\nAfter the quick-fix is applied:\n\n\n      Everybody be cool, this is a robbery!\n\nNew in 2021.1",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/Tokenizer.java",
      "language": "RegExp",
      "line": 26,
      "offset": 65,
      "length": 3,
      "code": {
        "startLine": 24,
        "length": 3,
        "offset": 83,
        "surroundingCode": "class Tokenizer {\n\n\tprivate static final Pattern PATTERN = Pattern.compile(\"\\\\s*(?:(?:(?:any|none)\\\\(\\\\))|[()!|&]|(?:[^\\\\s()!|&]+))\",\n\t\tCASE_INSENSITIVE);\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "RegExpUnnecessaryNonCapturingGroup"
  },
  "hash": "05ed20c3aab27a6306716d5debf7fbd358cd0731dd40b259d5557ac4320f4ac5"
},{
  "tool": "Code Inspection",
  "category": "RegExp",
  "type": "Unnecessary non-capturing group",
  "severity": "High",
  "comment": "Unnecessary non-capturing group '(?:[^s()!|&]+)'",
  "detailsInfo": "Reports unnecessary non-capturing groups, which have no influence on the match result.\n\n**Example:**\n\n\n      Everybody be cool, (?:this) is a robbery!\n\nAfter the quick-fix is applied:\n\n\n      Everybody be cool, this is a robbery!\n\nNew in 2021.1",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/Tokenizer.java",
      "language": "RegExp",
      "line": 26,
      "offset": 96,
      "length": 3,
      "code": {
        "startLine": 24,
        "length": 3,
        "offset": 114,
        "surroundingCode": "class Tokenizer {\n\n\tprivate static final Pattern PATTERN = Pattern.compile(\"\\\\s*(?:(?:(?:any|none)\\\\(\\\\))|[()!|&]|(?:[^\\\\s()!|&]+))\",\n\t\tCASE_INSENSITIVE);\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "RegExpUnnecessaryNonCapturingGroup"
  },
  "hash": "8bd0e5c26fdc5199ee3d0bd3820b5bb2438a1183bdcb04d19e6e68e344083bba"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Manual min/max calculation",
  "severity": "High",
  "comment": "Can be replaced with 'Math.min()' call",
  "detailsInfo": "Reports cases where the minimum or the maximum of two numbers can be calculated using a `Math.max()` or `Math.min()` call, instead of doing it manually.\n\n**Example:**\n\n\n      public int min(int a, int b) {\n        return b < a ? b : a;\n      }\n\nAfter the quick-fix is applied:\n\n\n      public int min(int a, int b) {\n        return Math.min(a, b);\n      }\n\n\nUse the **Disable for float and double** option to disable this inspection for `double` and `float` types.\nThis is useful because the quick-fix may slightly change the semantics for `float`/\n`double` types when handling `NaN`. Nevertheless, in most cases this will actually fix\na subtle bug where `NaN` is not taken into account.\n\nNew in 2019.2",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/MutableTestExecutionSummary.java",
      "language": "JAVA",
      "line": 253,
      "offset": 25,
      "length": 51,
      "code": {
        "startLine": 251,
        "length": 51,
        "offset": 138,
        "surroundingCode": "\t\tint duplicates = numberOfCommonFrames(trace, parentTrace);\n\t\tint numDistinctFrames = trace.length - duplicates;\n\t\tint numDisplayLines = (numDistinctFrames > max) ? max : numDistinctFrames;\n\t\tfor (int i = 0; i < numDisplayLines; i++) {\n\t\t\twriter.printf(\"%s%s%s%n\", indentation, TAB, trace[i]);"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "ManualMinMaxCalculation"
  },
  "hash": "5bbd9e92fe01baf2e826289da773ed3d1241047a68a5ad54f8f1c263c05123ee"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/TagExpressions.java",
      "language": "JAVA",
      "line": 74,
      "offset": 29,
      "length": 2,
      "code": {
        "startLine": 72,
        "length": 2,
        "offset": 71,
        "surroundingCode": "\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"!\" + toNegate + \"\";\n\t\t\t}\n\t\t};"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "2bdf4ec651831f365d7a10e8c930ff0be3673eabc351914db1a9ce6a04cb6307"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'Throwable' not thrown",
  "severity": "High",
  "comment": "Result of 'throwAsUncheckedException()' not thrown",
  "detailsInfo": "Reports instantiations of `Throwable` or its subclasses, where the created `Throwable` is never actually thrown. Additionally, this inspection reports method calls that return instances of `Throwable` or its subclasses, when the result of the method call is not thrown.\n\nCalls to methods annotated with the Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation will not be reported.\n\n**Example:**\n\n\n        void leftBehind() throws Throwable {\n            RuntimeException e = new RuntimeException(\"throw me\");\n            // ...\n        }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assumptions.java",
      "language": "JAVA",
      "line": 249,
      "offset": 20,
      "length": 25,
      "code": {
        "startLine": 247,
        "length": 25,
        "offset": 49,
        "surroundingCode": "\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tExceptionUtils.throwAsUncheckedException(t);\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ThrowableNotThrown"
  },
  "hash": "f7e21c76e76db6fbb8a4274db1ef3b716c72770a4a18d08d4f7fe07172a31ef8"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'Throwable' not thrown",
  "severity": "High",
  "comment": "Result of 'throwAsUncheckedException()' not thrown",
  "detailsInfo": "Reports instantiations of `Throwable` or its subclasses, where the created `Throwable` is never actually thrown. Additionally, this inspection reports method calls that return instances of `Throwable` or its subclasses, when the result of the method call is not thrown.\n\nCalls to methods annotated with the Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation will not be reported.\n\n**Example:**\n\n\n        void leftBehind() throws Throwable {\n            RuntimeException e = new RuntimeException(\"throw me\");\n            // ...\n        }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java",
      "language": "JAVA",
      "line": 81,
      "offset": 19,
      "length": 25,
      "code": {
        "startLine": 79,
        "length": 25,
        "offset": 47,
        "surroundingCode": "\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tExceptionUtils.throwAsUncheckedException(ex);\n\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-api.main",
    "inspectionName": "ThrowableNotThrown"
  },
  "hash": "713cedf8b4501a57b0e2c3148bb7f6391539b7c4f594deb8adeb55609e347495"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'Throwable' not thrown",
  "severity": "High",
  "comment": "Result of 'throwAsUncheckedException()' not thrown",
  "detailsInfo": "Reports instantiations of `Throwable` or its subclasses, where the created `Throwable` is never actually thrown. Additionally, this inspection reports method calls that return instances of `Throwable` or its subclasses, when the result of the method call is not thrown.\n\nCalls to methods annotated with the Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation will not be reported.\n\n**Example:**\n\n\n        void leftBehind() throws Throwable {\n            RuntimeException e = new RuntimeException(\"throw me\");\n            // ...\n        }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java",
      "language": "JAVA",
      "line": 105,
      "offset": 20,
      "length": 25,
      "code": {
        "startLine": 103,
        "length": 25,
        "offset": 49,
        "surroundingCode": "\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tExceptionUtils.throwAsUncheckedException(t);\n\t\t\t}\n\t\t});"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "ThrowableNotThrown"
  },
  "hash": "d0a51234792a238deae8171827eec6605000936ad87ceefe184bae48d342ec51"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'Throwable' not thrown",
  "severity": "High",
  "comment": "Result of 'throwAsUncheckedException()' not thrown",
  "detailsInfo": "Reports instantiations of `Throwable` or its subclasses, where the created `Throwable` is never actually thrown. Additionally, this inspection reports method calls that return instances of `Throwable` or its subclasses, when the result of the method call is not thrown.\n\nCalls to methods annotated with the Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation will not be reported.\n\n**Example:**\n\n\n        void leftBehind() throws Throwable {\n            RuntimeException e = new RuntimeException(\"throw me\");\n            // ...\n        }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java",
      "language": "JAVA",
      "line": 349,
      "offset": 19,
      "length": 25,
      "code": {
        "startLine": 347,
        "length": 25,
        "offset": 54,
        "surroundingCode": "\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\tExceptionUtils.throwAsUncheckedException(throwable);\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "ThrowableNotThrown"
  },
  "hash": "97fd7e012894b247c19c390b46c0e901a42e25181516aaacb0a9966c0fddaa8e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'Throwable' not thrown",
  "severity": "High",
  "comment": "Result of 'throwAsUncheckedException()' not thrown",
  "detailsInfo": "Reports instantiations of `Throwable` or its subclasses, where the created `Throwable` is never actually thrown. Additionally, this inspection reports method calls that return instances of `Throwable` or its subclasses, when the result of the method call is not thrown.\n\nCalls to methods annotated with the Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation will not be reported.\n\n**Example:**\n\n\n        void leftBehind() throws Throwable {\n            RuntimeException e = new RuntimeException(\"throw me\");\n            // ...\n        }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java",
      "language": "JAVA",
      "line": 118,
      "offset": 19,
      "length": 25,
      "code": {
        "startLine": 116,
        "length": 25,
        "offset": 78,
        "surroundingCode": "\t\t// No handlers left?\n\t\tif (exceptionHandlers.isEmpty()) {\n\t\t\tExceptionUtils.throwAsUncheckedException(throwable);\n\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "ThrowableNotThrown"
  },
  "hash": "408ad810109834c6fcf1c5c315ff87a52894c9f56ba8ae13bd7c04fd24630681"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'Throwable' not thrown",
  "severity": "High",
  "comment": "Result of 'throwAsUncheckedException()' not thrown",
  "detailsInfo": "Reports instantiations of `Throwable` or its subclasses, where the created `Throwable` is never actually thrown. Additionally, this inspection reports method calls that return instances of `Throwable` or its subclasses, when the result of the method call is not thrown.\n\nCalls to methods annotated with the Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation will not be reported.\n\n**Example:**\n\n\n        void leftBehind() throws Throwable {\n            RuntimeException e = new RuntimeException(\"throw me\");\n            // ...\n        }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ForkJoinPoolHierarchicalTestExecutorService.java",
      "language": "JAVA",
      "line": 174,
      "offset": 20,
      "length": 25,
      "code": {
        "startLine": 172,
        "length": 25,
        "offset": 60,
        "surroundingCode": "\t\t\t}\n\t\t\tcatch (InterruptedException e) {\n\t\t\t\tExceptionUtils.throwAsUncheckedException(e);\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-engine.main",
    "inspectionName": "ThrowableNotThrown"
  },
  "hash": "72271b4a1a524100f5b99f21d88743f051c03919fc7e0e8b0525a21e6b3e5b68"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'Throwable' not thrown",
  "severity": "High",
  "comment": "Result of 'throwAsUncheckedException()' not thrown",
  "detailsInfo": "Reports instantiations of `Throwable` or its subclasses, where the created `Throwable` is never actually thrown. Additionally, this inspection reports method calls that return instances of `Throwable` or its subclasses, when the result of the method call is not thrown.\n\nCalls to methods annotated with the Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation will not be reported.\n\n**Example:**\n\n\n        void leftBehind() throws Throwable {\n            RuntimeException e = new RuntimeException(\"throw me\");\n            // ...\n        }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
      "language": "JAVA",
      "line": 228,
      "offset": 21,
      "length": 25,
      "code": {
        "startLine": 226,
        "length": 25,
        "offset": 61,
        "surroundingCode": "\t\t\t\t}\n\t\t\t\tcatch (ExecutionException e) {\n\t\t\t\t\tExceptionUtils.throwAsUncheckedException(e.getCause());\n\t\t\t\t}\n\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-engine.main",
    "inspectionName": "ThrowableNotThrown"
  },
  "hash": "2a142d1e2b064389b6f6c8c819def6db3e080f88c93eaf7e15329335cd5cb352"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'Throwable' not thrown",
  "severity": "High",
  "comment": "Result of 'throwAsUncheckedException()' not thrown",
  "detailsInfo": "Reports instantiations of `Throwable` or its subclasses, where the created `Throwable` is never actually thrown. Additionally, this inspection reports method calls that return instances of `Throwable` or its subclasses, when the result of the method call is not thrown.\n\nCalls to methods annotated with the Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation will not be reported.\n\n**Example:**\n\n\n        void leftBehind() throws Throwable {\n            RuntimeException e = new RuntimeException(\"throw me\");\n            // ...\n        }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ThrowableCollector.java",
      "language": "JAVA",
      "line": 161,
      "offset": 19,
      "length": 25,
      "code": {
        "startLine": 159,
        "length": 25,
        "offset": 67,
        "surroundingCode": "\tpublic void assertEmpty() {\n\t\tif (!isEmpty()) {\n\t\t\tExceptionUtils.throwAsUncheckedException(this.throwable);\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-engine.main",
    "inspectionName": "ThrowableNotThrown"
  },
  "hash": "5293807c438903f45bd2a9b0fb5fee1e401a8bb87669e78cdf0a3e804f1651cf"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'Throwable' not thrown",
  "severity": "High",
  "comment": "Result of 'throwAsUncheckedException()' not thrown",
  "detailsInfo": "Reports instantiations of `Throwable` or its subclasses, where the created `Throwable` is never actually thrown. Additionally, this inspection reports method calls that return instances of `Throwable` or its subclasses, when the result of the method call is not thrown.\n\nCalls to methods annotated with the Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation will not be reported.\n\n**Example:**\n\n\n        void leftBehind() throws Throwable {\n            RuntimeException e = new RuntimeException(\"throw me\");\n            // ...\n        }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/BlacklistedExceptions.java",
      "language": "JAVA",
      "line": 57,
      "offset": 19,
      "length": 25,
      "code": {
        "startLine": 55,
        "length": 25,
        "offset": 173,
        "surroundingCode": "\tpublic static void rethrowIfBlacklisted(Throwable exception) {\n\t\tif (blacklist.stream().anyMatch(exceptionType -> exceptionType.isInstance(exception))) {\n\t\t\tExceptionUtils.throwAsUncheckedException(exception);\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "ThrowableNotThrown"
  },
  "hash": "2b3803d5eaa19d512676e8691afa218ee1020ae679e3785c0d62afc5ac8d9b44"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Redundant usage of unmodifiable collection wrappers",
  "severity": "High",
  "comment": "Redundant usage of the 'unmodifiableList' wrapper",
  "detailsInfo": "Reports redundant calls to unmodifiable collection wrappers within the `Collections` class.\n\nIf the argument that is passed to an unmodifiable\ncollection wrapper is already immutable, such a wrapping becomes redundant.\n\nExample:\n\n\n      Collections.unmodifiableList(Collections.singletonList(\"abc\"));\n\nIn order to detect the methods that return unmodifiable collections, the\ninspection uses the `org.jetbrains.annotations.Unmodifiable`\nand `org.jetbrains.annotations.UnmodifiableView` annotations.\nUse them to extend the inspection to your own unmodifiable collection\nwrappers.\n\nNew in 2020.3",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
      "language": "JAVA",
      "line": 998,
      "offset": 10,
      "length": 28,
      "code": {
        "startLine": 996,
        "length": 28,
        "offset": 113,
        "surroundingCode": "\t */\n\tpublic static List<Class<?>> findAllClassesInModule(String moduleName, ClassFilter classFilter) {\n\t\treturn Collections.unmodifiableList(ModuleUtils.findAllClassesInModule(moduleName, classFilter));\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "RedundantUnmodifiable"
  },
  "hash": "0a1920c9a659d41a4c75c37207b9c5b21b75e88c6070567d851ab544e7b458df"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Call to 'Arrays.asList()' with too few arguments",
  "severity": "High",
  "comment": "Call to 'asList()' with only one argument",
  "detailsInfo": "Reports calls to `Arrays.asList()` with at most one argument.\n\n\nSuch calls could be replaced\nwith `Collections.singletonList()`, `Collections.emptyList()`,\nor `List.of()` on JDK 9 and later, which will save some memory.\n\nIn particular, `Collections.emptyList()` and `List.of()` with no arguments\nalways return a shared instance,\nwhile `Arrays.asList()` with no arguments creates a new object every time it's called.\n\nNote: the lists returned by `Collections.singletonList()` and `List.of()` are immutable,\nwhile the list returned `Arrays.asList()` allows calling the `set()` method.\nThis may break the code in rare cases.\n\n**Example:**\n\n\n      List<String> empty = Arrays.asList();\n      List<String> one = Arrays.asList(\"one\");\n\nAfter the quick-fix is applied:\n\n\n      List<String> empty = Collections.emptyList();\n      List<String> one = Collections.singletonList(\"one\");\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-console/src/main/java/org/junit/platform/console/options/AvailableOptions.java",
      "language": "JAVA",
      "line": 179,
      "offset": 10,
      "length": 6,
      "code": {
        "startLine": 177,
        "length": 6,
        "offset": 111,
        "surroundingCode": "\t\t\t\t\t+ \"Default: ${DEFAULT-VALUE}\")\n\tprivate List<String> includeClassNamePatterns = new ArrayList<>(\n\t\tArrays.asList(ClassNameFilter.STANDARD_INCLUDE_PATTERN));\n\n\t@Option(names = { \"--n\", \"-include-classname\" }, arity = \"1\", hidden = true)"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-console.main",
    "inspectionName": "ArraysAsListWithZeroOrOneArgument"
  },
  "hash": "bef3270d462ba67591e008380f236832b768e4954b1bbab921a9f79e371f0c04"
},{
  "tool": "Code Inspection",
  "category": "Memory",
  "type": "Inner class may be 'static'",
  "severity": "High",
  "comment": "Inner class 'RewindableByteArrayOutputStream' may be 'static'",
  "detailsInfo": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/StreamInterceptor.java",
      "language": "JAVA",
      "line": 96,
      "offset": 8,
      "length": 31,
      "code": {
        "startLine": 94,
        "length": 31,
        "offset": 11,
        "surroundingCode": "\t}\n\n\tclass RewindableByteArrayOutputStream extends ByteArrayOutputStream {\n\n\t\tprivate final Deque<Integer> markedPositions = new ArrayDeque<>();"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "InnerClassMayBeStatic"
  },
  "hash": "968202878a6ff6e31c90357fa2402cd662520ce8a5ed61322a389d00a6d2cade"
},{
  "tool": "Code Inspection",
  "category": "Inheritance issues",
  "type": "Abstract class which has no concrete subclass",
  "severity": "High",
  "comment": "Abstract class 'AbstractJUnit3TestCase' has no concrete subclass",
  "detailsInfo": "Reports `abstract` classes that have no concrete subclasses.",
  "sources": [
    {
      "type": "file",
      "path": "junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit3/AbstractJUnit3TestCase.java",
      "language": "JAVA",
      "line": 20,
      "offset": 23,
      "length": 22,
      "code": {
        "startLine": 18,
        "length": 22,
        "offset": 41,
        "surroundingCode": " * @since 4.12\n */\npublic abstract class AbstractJUnit3TestCase extends TestCase {\n\n\tpublic void test() {"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-vintage-engine.testFixtures",
    "inspectionName": "AbstractClassNeverImplemented"
  },
  "hash": "edf73c77a9cd81c62f2c654e1aff3ef32181c82f44e1848e85d0fd96125699ed"
},{
  "tool": "Code Inspection",
  "category": "Inheritance issues",
  "type": "Abstract class which has no concrete subclass",
  "severity": "High",
  "comment": "Abstract class 'AbstractJunit4TestCaseWithConstructorParameter' has no concrete subclass",
  "detailsInfo": "Reports `abstract` classes that have no concrete subclasses.",
  "sources": [
    {
      "type": "file",
      "path": "junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/AbstractJunit4TestCaseWithConstructorParameter.java",
      "language": "JAVA",
      "line": 15,
      "offset": 23,
      "length": 46,
      "code": {
        "startLine": 13,
        "length": 46,
        "offset": 46,
        "surroundingCode": "import org.junit.Test;\n\npublic abstract class AbstractJunit4TestCaseWithConstructorParameter {\n\n\tpublic AbstractJunit4TestCaseWithConstructorParameter(int parameter) {"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-vintage-engine.testFixtures",
    "inspectionName": "AbstractClassNeverImplemented"
  },
  "hash": "e34c73c75c4141b2302269b45441f1841dbd0d8d121c903ad9ed6e27a5cb5129"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Optional.get() is called without isPresent() check",
  "severity": "High",
  "comment": "'Optional.get()' without 'isPresent()' check",
  "detailsInfo": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ConditionEvaluator.java",
      "language": "JAVA",
      "line": 75,
      "offset": 25,
      "length": 3,
      "code": {
        "startLine": 73,
        "length": 3,
        "offset": 243,
        "surroundingCode": "\tprivate void logResult(Class<?> conditionType, ConditionEvaluationResult result, ExtensionContext context) {\n\t\tlogger.trace(() -> format(\"Evaluation of condition [%s] on [%s] resulted in: %s\", conditionType.getName(),\n\t\t\tcontext.getElement().get(), result));\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalGetWithoutIsPresent"
  },
  "hash": "eb6f59326b4f268cb55dbaea8059e908b47d8220b11cc96f65d73242f0b67209"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Optional.get() is called without isPresent() check",
  "severity": "High",
  "comment": "'Optional.get()' without 'isPresent()' check",
  "detailsInfo": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/RepeatedTestExtension.java",
      "language": "JAVA",
      "line": 43,
      "offset": 94,
      "length": 3,
      "code": {
        "startLine": 41,
        "length": 3,
        "offset": 197,
        "surroundingCode": "\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tString displayName = context.getDisplayName();\n\t\tRepeatedTest repeatedTest = AnnotationUtils.findAnnotation(testMethod, RepeatedTest.class).get();\n\t\tint totalRepetitions = totalRepetitions(repeatedTest, testMethod);\n\t\tRepeatedTestDisplayNameFormatter formatter = displayNameFormatter(repeatedTest, testMethod, displayName);"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalGetWithoutIsPresent"
  },
  "hash": "f8b0a815e3c5992818399ae7fd669871cce6234069acab9df0a40c314a7de947"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Optional.get() is called without isPresent() check",
  "severity": "High",
  "comment": "'Optional.get()' without 'isPresent()' check",
  "detailsInfo": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/DisabledCondition.java",
      "language": "JAVA",
      "line": 46,
      "offset": 19,
      "length": 3,
      "code": {
        "startLine": 44,
        "length": 3,
        "offset": 140,
        "surroundingCode": "\t\tif (disabled.isPresent()) {\n\t\t\tString reason = disabled.map(Disabled::value).filter(StringUtils::isNotBlank).orElseGet(\n\t\t\t\t() -> element.get() + \" is @Disabled\");\n\t\t\treturn ConditionEvaluationResult.disabled(reason);\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-engine.main",
    "inspectionName": "OptionalGetWithoutIsPresent"
  },
  "hash": "7a23b9a7c355fb2e243f51204f1601ffde3345f1b3d9c51cfa392eda8285227e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Optional.get() is called without isPresent() check",
  "severity": "High",
  "comment": "'Optional.get()' without 'isPresent()' check",
  "detailsInfo": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java",
      "language": "JAVA",
      "line": 123,
      "offset": 97,
      "length": 3,
      "code": {
        "startLine": 121,
        "length": 3,
        "offset": 250,
        "surroundingCode": "\tprivate ParameterizedTestNameFormatter createNameFormatter(Method templateMethod,\n\t\t\tParameterizedTestMethodContext methodContext, String displayName) {\n\t\tParameterizedTest parameterizedTest = findAnnotation(templateMethod, ParameterizedTest.class).get();\n\t\tString pattern = Preconditions.notBlank(parameterizedTest.name().trim(),\n\t\t\t() -> String.format("
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-params.main",
    "inspectionName": "OptionalGetWithoutIsPresent"
  },
  "hash": "b964ccda7be036d9312d1bfb4797a6011941a65fea5e97ce0df18d77c93dbae9"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Optional.get() is called without isPresent() check",
  "severity": "High",
  "comment": "'Optional::get' without 'isPresent()' check",
  "detailsInfo": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/TestRun.java",
      "language": "JAVA",
      "line": 193,
      "offset": 10,
      "length": 13,
      "code": {
        "startLine": 191,
        "length": 13,
        "offset": 67,
        "surroundingCode": "\t\t\t\t.stream()\n\t\t\t\t.map(TestExecutionResult::getThrowable)\n\t\t\t\t.map(Optional::get)\n\t\t\t\t.collect(toList());\n\t\t// @formatter:on"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-vintage-engine.main",
    "inspectionName": "OptionalGetWithoutIsPresent"
  },
  "hash": "1b693328505ff8cb53f8a965833516e1d9a9357711c4eb4767c09115c9c46733"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Optional.get() is called without isPresent() check",
  "severity": "High",
  "comment": "'Optional.get()' without 'isPresent()' check",
  "detailsInfo": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/CompositeFilter.java",
      "language": "JAVA",
      "line": 76,
      "offset": 6,
      "length": 3,
      "code": {
        "startLine": 74,
        "length": 3,
        "offset": 63,
        "surroundingCode": "\t\t\t\t.map(Filter::toPredicate)\n\t\t\t\t.reduce(Predicate::and)\n\t\t\t\t.get(); // it's safe to call get() here because the constructor ensures filters is not empty\n\t\t// @formatter:on\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-engine.main",
    "inspectionName": "OptionalGetWithoutIsPresent"
  },
  "hash": "4cbc30d509887bc4b7af04cf0834963225db0b7f503a47f12d16707921f541cc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Optional.get() is called without isPresent() check",
  "severity": "High",
  "comment": "'Optional.get()' without 'isPresent()' check",
  "detailsInfo": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-engine/src/testFixtures/java/org/junit/platform/engine/support/hierarchical/DemoHierarchicalEngineDescriptor.java",
      "language": "JAVA",
      "line": 30,
      "offset": 42,
      "length": 3,
      "code": {
        "startLine": 28,
        "length": 3,
        "offset": 104,
        "surroundingCode": "\n\tpublic DemoHierarchicalEngineDescriptor(UniqueId uniqueId) {\n\t\tsuper(uniqueId, uniqueId.getEngineId().get());\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-engine.testFixtures",
    "inspectionName": "OptionalGetWithoutIsPresent"
  },
  "hash": "10a421585f33de69eeb61333a57320359326b11001dd7a0c8a6e9babbc6bbe5b"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Optional.get() is called without isPresent() check",
  "severity": "High",
  "comment": "'Optional.get()' without 'isPresent()' check",
  "detailsInfo": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-runner/src/main/java/org/junit/platform/runner/JUnitPlatformRunnerListener.java",
      "language": "JAVA",
      "line": 40,
      "offset": 50,
      "length": 3,
      "code": {
        "startLine": 38,
        "length": 3,
        "offset": 128,
        "surroundingCode": "\t@Override\n\tpublic void dynamicTestRegistered(TestIdentifier testIdentifier) {\n\t\tString parentId = testIdentifier.getParentId().get();\n\t\ttestTree.addDynamicDescription(testIdentifier, parentId);\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-runner.main",
    "inspectionName": "OptionalGetWithoutIsPresent"
  },
  "hash": "dd9822e7062108ea973cc8de6ebb0a49939c422ec76a21c256280561986ccc5c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Optional.get() is called without isPresent() check",
  "severity": "High",
  "comment": "'Optional.get()' without 'isPresent()' check",
  "detailsInfo": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java",
      "language": "JAVA",
      "line": 283,
      "offset": 100,
      "length": 3,
      "code": {
        "startLine": 281,
        "length": 3,
        "offset": 208,
        "surroundingCode": "\t\t\t\t// Nested container annotation?\n\t\t\t\telse if (isRepeatableAnnotationContainer(candidateAnnotationType)) {\n\t\t\t\t\tMethod method = ReflectionUtils.tryToGetMethod(candidateAnnotationType, \"value\").toOptional().get();\n\t\t\t\t\tAnnotation[] containedAnnotations = (Annotation[]) ReflectionUtils.invokeMethod(method, candidate);\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-commons.main",
    "inspectionName": "OptionalGetWithoutIsPresent"
  },
  "hash": "a014ad47853784c99cdbc5e7ff77c18ce777bbaf79349a381ce2c2bcaceacbfa"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Optional.get() is called without isPresent() check",
  "severity": "High",
  "comment": "'Optional.get()' without 'isPresent()' check",
  "detailsInfo": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/ParseResult.java",
      "language": "JAVA",
      "line": 44,
      "offset": 26,
      "length": 3,
      "code": {
        "startLine": 42,
        "length": 3,
        "offset": 84,
        "surroundingCode": "\t\t\tthrow exceptionCreator.apply(errorMessage().get());\n\t\t}\n\t\treturn tagExpression().get();\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-platform-launcher.main",
    "inspectionName": "OptionalGetWithoutIsPresent"
  },
  "hash": "eec6969c5cec972e77e17d2516efe7f62bc06e1fa83f9156ad2d982cb6da45b6"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Optional.get() is called without isPresent() check",
  "severity": "High",
  "comment": "'Optional.get()' without 'isPresent()' check",
  "detailsInfo": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "junit-jupiter-migrationsupport/src/main/java/org/junit/jupiter/migrationsupport/conditions/IgnoreCondition.java",
      "language": "JAVA",
      "line": 53,
      "offset": 31,
      "length": 3,
      "code": {
        "startLine": 51,
        "length": 3,
        "offset": 129,
        "surroundingCode": "\t\t\tString reason = ignoreAnnotation.map(Ignore::value) //\n\t\t\t\t\t.filter(StringUtils::isNotBlank) //\n\t\t\t\t\t.orElseGet(() -> element.get() + \" is disabled via @org.junit.Ignore\");\n\t\t\treturn ConditionEvaluationResult.disabled(reason);\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-jupiter-migrationsupport.main",
    "inspectionName": "OptionalGetWithoutIsPresent"
  },
  "hash": "ba1b94b31e95055e1474066b7d6246cb566f8b34c6b872b08181ef333e39d3ca"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "severity": "High",
  "comment": "'plugins(org.gradle.api.Action)' is marked unstable with @Incubating",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "settings.gradle.kts",
      "language": "kotlin",
      "line": 4,
      "offset": 2,
      "length": 7,
      "code": {
        "startLine": 2,
        "length": 7,
        "offset": 21,
        "surroundingCode": "\npluginManagement {\n\tplugins {\n\t\tid(\"com.gradle.enterprise\") version \"3.3.1\"\n\t\tid(\"net.nemerosa.versioning\") version \"2.12.1\""
      }
    }
  ],
  "attributes": {
    "module": "junit5",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "e3ce379a8f31455f2dd52a36abadcc2b8c7d19f2cd53224145c9da31d77570e4"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "severity": "High",
  "comment": "'constraints(kotlin.jvm.functions.Function1)' is marked unstable with @Incubating",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "junit-bom/junit-bom.gradle.kts",
      "language": "kotlin",
      "line": 10,
      "offset": 2,
      "length": 11,
      "code": {
        "startLine": 8,
        "length": 11,
        "offset": 17,
        "surroundingCode": "\ndependencies {\n\tconstraints {\n\t\tval mavenizedProjects: List<Project> by rootProject.extra\n\t\tmavenizedProjects.sorted()"
      }
    }
  ],
  "attributes": {
    "module": "junit5.junit-bom",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "815c0328b0f66c4127f8b1a93d182b0853966c22e102e2080b16dabf8ff14dff"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "severity": "High",
  "comment": "'constraints(kotlin.jvm.functions.Function1)' is marked unstable with @Incubating",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "dependencies/dependencies.gradle.kts",
      "language": "kotlin",
      "line": 6,
      "offset": 2,
      "length": 11,
      "code": {
        "startLine": 4,
        "length": 11,
        "offset": 17,
        "surroundingCode": "\ndependencies {\n\tconstraints {\n\t\t// api means \"the dependency is for both compilation and runtime\"\n\t\t// runtime means \"the dependency is only for runtime, not for compilation\""
      }
    }
  ],
  "attributes": {
    "module": "junit5.dependencies",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "628403f6e6f4d8360d86fbc38b0f55dab4bafc12ea9345d793a4a93ccb49e092"
}]}